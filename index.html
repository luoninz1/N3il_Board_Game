<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>No‑Three‑in‑Line — Interactive Chess‑Style Board (v3)</title>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #161a22;
      --panel-2: #1d2330;
      --text: #e7ecf3;
      --muted: #9aa4b2;
      --accent: #8ab4ff;
      --danger: #ff6b6b;
      --ok: #7ae582;
    }
    * { box-sizing: border-box; }
    body { margin: 0; padding: 24px; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; }
    h1 { font-size: 20px; margin: 0 0 12px; font-weight: 700; letter-spacing: .2px; }
    .app { max-width: 1100px; margin: 0 auto; display: grid; gap: 16px; grid-template-columns: 360px 1fr; }
    @media (max-width: 980px) { 
      .app { grid-template-columns: 1fr; }
      .panel.controls { order: 2; }
      .board-wrap { order: 1; }
    }
    @media (max-width: 480px) {
      body { padding: 12px; }
      .app { gap: 12px; }
      .panel { padding: 12px; }
      .row { margin-bottom: 12px; }
      h1 { font-size: 18px; }
    }

    .panel { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid #202636; border-radius: 16px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,.3); }
    .controls label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: end; margin-bottom: 14px; }
    .row.two { grid-template-columns: 1fr 1fr; }
    input[type=number], input[type=text], select { width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #2a3244; outline: none; background: #121723; color: var(--text); min-height: 44px; /* Better touch target */ }
    button { cursor: pointer; border: 1px solid #2a3244; border-radius: 12px; padding: 10px 14px; background: #121723; color: var(--text); font-weight: 600; letter-spacing: .2px; min-height: 44px; /* Better touch target */ }
    button:hover { border-color: #3a435a; }
    button.accent { background: #172034; border-color: #26324d; color: var(--accent); }
    button.danger { background: #2a1418; border-color: #4a1d25; color: var(--danger); }

    .status { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px; }
    .stat { background: rgba(255,255,255,.03); border: 1px solid #202636; border-radius: 12px; padding: 10px 12px; }
    .stat .k { font-size: 11px; color: var(--muted); }
    .stat .v { font-size: 18px; font-weight: 700; }

    .legend { font-size: 12px; color: var(--muted); margin-top: 10px; line-height: 1.5; }

    .board-wrap { position: relative; }
    canvas { 
      width: 100%; 
      height: auto; 
      display: block; 
      background: #f1d59a; 
      border-radius: 16px; 
      border: 1px solid #e0c074;
      touch-action: none; /* Prevent default touch behaviors */
      user-select: none; /* Prevent text selection */
      -webkit-user-select: none;
      -webkit-touch-callout: none; /* Prevent callout on iOS */
    }
    .toast { position: absolute; top: 12px; right: 12px; background: rgba(22,26,34,.85); border: 1px solid #30384e; color: var(--text); padding: 10px 12px; border-radius: 12px; font-size: 13px; pointer-events: none; opacity: 0; transform: translateY(-6px); transition: .22s ease; }
    .toast.show { opacity: 1; transform: translateY(0); }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; font-weight: 700; font-size: 11px; vertical-align: baseline; }
    .pill.ok { background: #0f2a18; color: var(--ok); border: 1px solid #184b2a; }
    .pill.no { background: #2a161a; color: var(--danger); border: 1px solid #4a1d25; }

    .hint { font-size: 12px; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <h1>No‑Three‑in‑Line — Chess‑Style Board</h1>
  <div class="app">
    <section class="panel controls">
      <div class="row two">
        <div>
          <label>Board size (n × n)</label>
          <input id="sizeInput" type="number" min="3" max="50" step="1" value="3" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="applySize" class="accent" title="Reset and apply size">Apply Size</button>
        </div>
      </div>

      <div class="row two">
        <button id="undoBtn">Undo</button>
        <button id="resetBtn" class="danger">Reset</button>
      </div>

      <div class="row">
        <div>
          <label>Export / Import position</label>
          <input id="positionIO" type="text" placeholder="e.g. (3,5);(6,6);(10,2)" />
        </div>
        <button id="loadBtn" title="Load coordinates">Load</button>
      </div>

      <div class="status">
        <div class="stat">
          <div class="k">Current stones</div>
          <div class="v" id="stoneCount">0</div>
        </div>
        <div class="stat">
          <div class="k">Personal best (this size)</div>
          <div class="v" id="bestCount">0</div>
        </div>
      </div>

      <div class="row two" style="margin-top:8px;">
        <button id="completeBtn" title="Toggle complete detection lines">Complete Detection: OFF</button>
        <div></div>
      </div>

      <div class="legend">
        <strong>Play:</strong> Click a square to place a stone; click the same square again to remove it. <br/>
        <strong>Rule:</strong> Goal is to maximize stones such that no three lie on a straight line. Lines include any slope (horizontal, vertical, diagonal, or arbitrary). <br/>
        If placing a stone creates a line of ≥3 stones, the stone is still placed but shown <strong style="color:#ff6b6b">red</strong> (invalid) and does not count toward Personal Best. All lines with ≥3 stones are drawn as solid red segments spanning the outermost stones on that line. <br/>
  <strong>Complete Detection:</strong> When ON, every pair of stones generates a faint red line across the entire board (clipped to the edges). Every empty square lying anywhere on those discrete lattice lines is shaded translucent red. Use this to visualize future conflicts; turn OFF for a cleaner view. <br/>
        Personal Best counts only valid (non‑red) stones.
      </div>
      <div class="hint">Tip: You can paste/export coordinates from the box above to share a configuration.</div>
    </section>

    <section class="panel board-wrap">
      <div id="toast" class="toast">&nbsp;</div>
      <canvas id="board" width="900" height="900" aria-label="Go board canvas" role="img"></canvas>
    </section>
  </div>

  <script>
    // --- Utilities ---
    const $ = (sel) => document.querySelector(sel);
    const DPR = window.devicePixelRatio || 1;

    function keyFor(p) { return `${p.x},${p.y}`; }
    function collinear(a,b,c){
      // area of triangle == 0
      return (a.x*(b.y - c.y) + b.x*(c.y - a.y) + c.x*(a.y - b.y)) === 0;
    }
  function igcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }

    // --- State ---
    let n = 3;                 // board size
    // stones now store validity: {x,y, invalid:boolean}
    let stones = [];
    let stoneSet = new Set();   // occupancy key "x,y"
    let lastInvalidTriplet = null; // [[a],[b],[c]] for feedback line
  let completeDetectionOn = false; // toggled by button

    // --- Canvas & drawing ---
    const canvas = $('#board');
    const ctx = canvas.getContext('2d');

    let _canvasSized = false;
    function sizeCanvasOnce(){
      if (_canvasSized) return;
      // Decide an initial square size that fits the board container and viewport.
      const container = canvas.parentElement; // .board-wrap
      const available = Math.min(container.clientWidth || 900, window.innerWidth - 48, 1200);
      const cssSize = Math.max(200, Math.min(available, 900));
      // Fix CSS size so it never changes automatically.
      canvas.style.width = cssSize + 'px';
      canvas.style.height = cssSize + 'px';
      // Match backing store to DPR for crisp lines.
      canvas.width = Math.round(cssSize * DPR);
      canvas.height = Math.round(cssSize * DPR);
      _canvasSized = true;
    }

    function drawBoard(){
      sizeCanvasOnce();
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

  // Flat background
  ctx.fillStyle = '#e9d1a1';
  ctx.fillRect(0,0,W,H);

  // Chess board geometry
  const margin = Math.round(0.08 * W);
  const size = Math.min(W,H) - 2*margin;
  const cell = size / n; // n squares per side

      // Store layout for hit‑testing
      canvas._layout = {margin, size, cell, W, H};

      // Chess squares
      const light = '#f4dcaf';
      const dark = '#d6b078';
      for(let sy=0; sy<n; sy++){
        for(let sx=0; sx<n; sx++){
          ctx.fillStyle = ((sx + sy) & 1) ? dark : light;
          ctx.fillRect(margin + sx*cell, margin + sy*cell, cell, cell);
        }
      }
      // Board border
      ctx.strokeStyle = '#8c6a33'; ctx.lineWidth = 2 * DPR;
      ctx.strokeRect(margin, margin, size, size);

      // Collinear line visualization: any line with >=3 stones
      if(stones.length >= 3){
        const lineMap = new Map();
        for(let i=0;i<stones.length;i++){
          for(let j=i+1;j<stones.length;j++){
            const a=stones[i], b=stones[j];
            let dx=b.x - a.x, dy=b.y - a.y;
            if(dx===0 && dy===0) continue;
            const g=igcd(dx,dy); dx/=g; dy/=g;
            if(dx<0 || (dx===0 && dy<0)){ dx=-dx; dy=-dy; }
            const c = dx*a.y - dy*a.x; // invariant for line
            const key = dx+','+dy+','+c;
            let entry = lineMap.get(key);
            if(!entry){ entry = {dx,dy,c, idxs: new Set()}; lineMap.set(key, entry); }
            entry.idxs.add(i); entry.idxs.add(j);
          }
        }
        ctx.strokeStyle = '#c74b4b'; ctx.lineWidth = 2.5*DPR; ctx.lineCap = 'round';
        for(const entry of lineMap.values()){
          if(entry.idxs.size < 3) continue;
            let minP=null, maxP=null, minT=Infinity, maxT=-Infinity;
            // parameter t using projection onto direction (dx,dy)
            for(const idx of entry.idxs){
              const p = stones[idx];
              const t = entry.dx*p.x + entry.dy*p.y;
              if(t < minT){ minT = t; minP = p; }
              if(t > maxT){ maxT = t; maxP = p; }
            }
            if(minP && maxP){
              const x1 = margin + (minP.x + 0.5)*cell;
              const y1 = margin + (minP.y + 0.5)*cell;
              const x2 = margin + (maxP.x + 0.5)*cell;
              const y2 = margin + (maxP.y + 0.5)*cell;
              ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
            }
        }
      }

      // Complete detection: pairwise lines + intermediate empty square highlighting
  if(completeDetectionOn && stones.length >= 2){
        ctx.save();
        ctx.strokeStyle = 'rgba(198,75,75,0.6)';
        ctx.lineWidth = 1.5 * DPR;
        const emptiesToMark = new Set(); // key: x,y
        for(let i=0;i<stones.length;i++){
          for(let j=i+1;j<stones.length;j++){
            const a = stones[i], b = stones[j];
            let dx = b.x - a.x, dy = b.y - a.y;
            const g = igcd(dx,dy);
            if(g === 0) continue;
            dx /= g; dy /= g; // step of one lattice unit along line
            // Compute full board-clipped line through centers of a & b
            const cx0 = a.x + 0.5, cy0 = a.y + 0.5;
            const dirx = dx, diry = dy;
            let tmin = -Infinity, tmax = Infinity;
            function clampDim(p0, dp, minB, maxB){
              if(dp === 0){ if(p0 < minB || p0 > maxB) return false; return true; }
              const t1 = (minB - p0)/dp; const t2 = (maxB - p0)/dp;
              const lo = Math.min(t1,t2), hi = Math.max(t1,t2);
              if(lo > tmin) tmin = lo; if(hi < tmax) tmax = hi; return tmin <= tmax;
            }
            if(!clampDim(cx0, dirx, 0, n) || !clampDim(cy0, diry, 0, n)) continue;
            const ex1x = cx0 + tmin*dirx, ex1y = cy0 + tmin*diry;
            const ex2x = cx0 + tmax*dirx, ex2y = cy0 + tmax*diry;
            ctx.beginPath();
            ctx.moveTo(margin + ex1x*cell, margin + ex1y*cell);
            ctx.lineTo(margin + ex2x*cell, margin + ex2y*cell);
            ctx.stroke();
            // Walk entire discrete line segment across board collecting empty squares
            // Find starting lattice point along direction by stepping backwards
            let sx = a.x, sy = a.y;
            while(true){
              const nx = sx - dx, ny = sy - dy;
              if(nx < 0 || nx >= n || ny < 0 || ny >= n) break;
              sx = nx; sy = ny;
            }
            for(let lx = sx, ly = sy; lx >= 0 && lx < n && ly >= 0 && ly < n; lx += dx, ly += dy){
              const key = lx + ',' + ly;
              if(!stoneSet.has(key)) emptiesToMark.add(key);
            }
          }
        }
        // highlight empty squares
        ctx.fillStyle = 'rgba(255,70,70,0.35)';
        for(const key of emptiesToMark){
          const [sx,sy] = key.split(',').map(Number);
          ctx.fillRect(margin + sx*cell, margin + sy*cell, cell, cell);
        }
        ctx.restore();
      }

      // Stones — centered in squares now
      const rBase = Math.max(5*DPR, 0.45 * cell);
      stones.forEach((p)=>{
        const x = margin + (p.x + 0.5)*cell, y = margin + (p.y + 0.5)*cell;
        const r = rBase;
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,.15)';
        ctx.beginPath(); ctx.arc(x + 1*DPR, y + 1*DPR, r, 0, Math.PI*2); ctx.fill();
        // stone fill (red if invalid)
        ctx.fillStyle = p.invalid ? '#e44848' : '#0c0f14';
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        // glossy highlight on valid stones only
        if(!p.invalid){
          const rg = ctx.createRadialGradient(x - 0.35*r, y - 0.35*r, r*0.1, x, y, r);
          rg.addColorStop(0, 'rgba(255,255,255,.22)');
          rg.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        }
      });

      // Edge coordinates centered relative to squares
      ctx.fillStyle = '#2c2f38'; ctx.font = `${12*DPR}px ui-sans-serif, system-ui`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      for(let i=0;i<n;i++){
        const cx = margin + (i+0.5)*cell; const cy = margin + (i+0.5)*cell;
        const colLabel = String.fromCharCode(65 + i);
        const rowLabel = (i+1).toString();
        ctx.fillText(colLabel, cx, margin - 12*DPR);
        ctx.fillText(colLabel, cx, margin + size + 12*DPR);
        ctx.fillText(rowLabel, margin - 12*DPR, cy);
        ctx.fillText(rowLabel, margin + size + 12*DPR, cy);
      }
    }

    // --- Game logic ---
    function showToast(html){
      const t = $('#toast');
      t.innerHTML = html; t.classList.add('show');
      clearTimeout(t._timer);
      t._timer = setTimeout(()=> t.classList.remove('show'), 1500);
    }

    function updateCounters(){
      // Total stones (for UI) still shows all stones placed
      $('#stoneCount').textContent = stones.length;
      // Personal best must count only valid stones
      const validCount = stones.reduce((acc, p) => acc + (p.invalid ? 0 : 1), 0);
      const bestKey = `n3il-best-${n}`;
      const stored = Number(localStorage.getItem(bestKey) || 0);
      const best = Math.max(stored, validCount);
      localStorage.setItem(bestKey, best);
      $('#bestCount').textContent = best;
    }

    function reset(newN=null){
      if(newN){ 
        n = newN; 
        // Update input field to match
        $('#sizeInput').value = n;
      }
      stones = []; stoneSet = new Set(); lastInvalidTriplet = null;
      drawBoard(); updateCounters();
    }

    function nearestGridPoint(evt){
      const rect = canvas.getBoundingClientRect();
      const clientX = evt.clientX || (evt.touches && evt.touches[0] && evt.touches[0].clientX);
      const clientY = evt.clientY || (evt.touches && evt.touches[0] && evt.touches[0].clientY);
      if (clientX === undefined || clientY === undefined) return null;
      const x = (clientX - rect.left) * DPR;
      const y = (clientY - rect.top) * DPR;
      const {margin, cell} = canvas._layout;
      if(x < margin || y < margin) return null;
      const relX = x - margin;
      const relY = y - margin;
      if(relX < 0 || relY < 0) return null;
      const gx = Math.floor(relX / cell);
      const gy = Math.floor(relY / cell);
      if(gx < 0 || gx >= n || gy < 0 || gy >= n) return null;
      return {x: gx, y: gy};
    }

    function wouldCreateThreeInLine(newP){
      const k = stones.length;
      for(let i=0;i<k;i++){
        for(let j=i+1;j<k;j++){
          const a = stones[i], b = stones[j];
          if(collinear(a,b,newP)) return [a,b,newP];
        }
      }
      return null;
    }

    function placeStone(p){
      const k = keyFor(p);
      // Toggle behavior: remove if exists
      if(stoneSet.has(k)){
        for(let i=0;i<stones.length;i++){
          if(stones[i].x===p.x && stones[i].y===p.y){ stones.splice(i,1); break; }
        }
        stoneSet.delete(k); lastInvalidTriplet = null; drawBoard(); updateCounters();
        showToast('<span class="pill ok">Removed</span> Stone removed.');
        return;
      }
      // Try to place; mark invalid if it creates a 3‑in‑line
      const trip = wouldCreateThreeInLine(p);
      lastInvalidTriplet = trip; // keep visual feedback
      if(trip){
        stones.push({...p, invalid:true});
        stoneSet.add(k);
        drawBoard(); updateCounters();
        showToast('<span class="pill no">Marked</span> Collinear — shown in red.');
        return;
      }
      stones.push({...p, invalid:false}); stoneSet.add(k);
      drawBoard(); updateCounters();
      showToast('<span class="pill ok">Placed</span> Nice!');
    }

    // --- Interactions ---
    function handlePointerEvent(e) {
      e.preventDefault(); // Prevent scrolling on touch
      
      // Ensure board size hasn't changed unexpectedly
      const inputValue = Number($('#sizeInput').value || 3);
      if (inputValue !== n) {
        console.warn('Board size mismatch detected, fixing...');
        $('#sizeInput').value = n;
      }
      
      const p = nearestGridPoint(e);
      if(!p){ showToast('Click near an intersection.'); return; }
      placeStone(p);
    }

    canvas.addEventListener('click', handlePointerEvent);
    canvas.addEventListener('touchstart', handlePointerEvent, { passive: false });

    // Prevent zoom on double-tap for mobile
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
    }, { passive: false });

  // Intentionally do not auto-resize on window resize to avoid feedback loops.

    $('#applySize').addEventListener('click', ()=>{
      const v = Math.max(3, Math.min(50, Number($('#sizeInput').value||3)));
      $('#sizeInput').value = v;
      reset(v);
    });

    // Complete detection toggle
    $('#completeBtn').addEventListener('click', () => {
      completeDetectionOn = !completeDetectionOn;
      $('#completeBtn').textContent = `Complete Detection: ${completeDetectionOn ? 'ON' : 'OFF'}`;
      drawBoard();
    });

    $('#resetBtn').addEventListener('click', ()=> reset());

    $('#undoBtn').addEventListener('click', ()=>{
      const p = stones.pop();
      if(p){ stoneSet.delete(keyFor(p)); lastInvalidTriplet = null; drawBoard(); updateCounters(); }
    });

    $('#loadBtn').addEventListener('click', ()=>{
      const txt = ($('#positionIO').value||'').trim();
      if(!txt){ showToast('Paste coordinates like (3,5);(6,6)'); return; }
      const coords = [];
      const re = /\((\d+)\s*,\s*(\d+)\)/g;
      let m; while((m = re.exec(txt))!==null){ coords.push({x: Number(m[1]), y: Number(m[2])}); }
      if(!coords.length){ showToast('Could not parse coordinates.'); return; }
      for(const p of coords){ if(p.x<0||p.x>n-1||p.y<0||p.y>n-1){ showToast('Some points out of range for current board.'); return; } }
      stones = []; stoneSet = new Set(); lastInvalidTriplet = null;
      for(const p of coords){
        const k = keyFor(p);
        if(stoneSet.has(k)) continue;
        const trip = wouldCreateThreeInLine(p);
        if(trip){ lastInvalidTriplet = trip; stones.push({...p, invalid:true}); stoneSet.add(k); }
        else { stones.push({...p, invalid:false}); stoneSet.add(k); }
      }
      drawBoard(); updateCounters();
    });

    // Export on focus
    $('#positionIO').addEventListener('focus', ()=>{
      const s = stones.map(p=>`(${p.x},${p.y})`).join(';');
      $('#positionIO').value = s;
      $('#positionIO').select();
    });

    // Init with optional query string override (?n=15 or ?size=15)
    (function(){
      try {
        const params = new URLSearchParams(window.location.search);
        const qs = params.get('n') || params.get('size');
        if(qs!=null){
          let v = parseInt(qs,10);
          if(!Number.isNaN(v)){
            v = Math.max(3, Math.min(50, v));
            n = v;
            $('#sizeInput').value = v;
          }
        }
        const cdParam = params.get('complete') || params.get('cd');
        if(cdParam!=null){
          completeDetectionOn = /^(1|true|on|yes)$/i.test(cdParam);
        }
      } catch(e) { /* ignore */ }
      const btn = $('#completeBtn');
      if(btn){ btn.textContent = `Complete Detection: ${completeDetectionOn ? 'ON' : 'OFF'}`; }
      reset(n);
    })();
  </script>
</body>
</html>